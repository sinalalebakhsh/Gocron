package features

type SingleDefinitions struct {
	SingleDef map[string]string
}

var OriginSingleDef = SingleDefinitions{

	SingleDef: map[string]string{
		// Introduction
		"go":               "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"golang":           "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"gopher":           "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"gophers":          "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is go?":      "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is go ?":     "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is golang?":  "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		"what is golang ?": "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev. Go (often referred to as Golang) is a statically-typed programming language known for its simplicity, efficiency, and strong support for concurrent programming. It was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson and was first released to the public in 2009.",
		// Go documentation
		"godoc":                      "Godoc is a Go package that lets you create, manage, and use Go documentation in ‚Äúthe Go way‚Äù. for installing: sudo apt install golang-golang-x-tools. The Go way is a set of principles that, as a Go programmer, you should follow to improve code quality. Using Godoc, you can easily read other developers' documentation and code. You can also automate the creation of your own documentation and publish it using Godoc.Godoc is similar to Javadoc, the code documentor for Java. They both use comments and code in modules to generate documentation. And both tools structure that documentation in HTML so you can view it in a browser.",
		"what is godoc?":             "Godoc is a Go package that lets you create, manage, and use Go documentation in ‚Äúthe Go way‚Äù. for installing: sudo apt install golang-golang-x-tools. The Go way is a set of principles that, as a Go programmer, you should follow to improve code quality. Using Godoc, you can easily read other developers' documentation and code. You can also automate the creation of your own documentation and publish it using Godoc.Godoc is similar to Javadoc, the code documentor for Java. They both use comments and code in modules to generate documentation. And both tools structure that documentation in HTML so you can view it in a browser.",
		"install godoc":              "Run this in Terminal ===> sudo apt install golang-golang-x-tools",
		"getting started with godoc": "install the Godoc package from the golang website using this command: go get golang.org/x/tools/cmd/godoc. Conventionally, Go developers use port 6060 to host documentation. This is the command for running a Godoc server on that port: godoc -http=:6060 .  The command above hosts your code documentation on localhost, or 127.0.0.1. The port doesn't have to 6060; godoc will run on any unoccupied port. However, it's always best to follow the Go documentation conventions.",
		"about go":                   "Fans of Go (called gophers) describe Go as having the expressiveness of dynamic languages like Python or Ruby, with the performance of compiled languages like C or C++. The language is open source, and was started by engineers at Google. It's written using a C-style syntax, has statically typed variables, manages memory using garbage collection, and is compiled into stand-alone executables. Go is noted for the concurrent programming features built into the language core, the networking packages in the standard library (such as a web server), fast compilation and execution speed. Its simple, minimalistic and consistent language design make for a delightful experience, while the abundant and thoughtful tooling addresses traditional problems such as consistent formatting and documentation. The home page for Go is go.dev, and there is an excellent interactive tutorial at tour.go.dev.",

		"create environment go":      "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"create go project":          "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"go project":                 "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"environment go":             "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"go environment":             "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"create go environment":      "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"run go environment":         "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"run go environment project": "0.Create Environment GO in Command Line Interface Go: 1- go mod init YOURNAME 2- go work init YOURWORKDIRECTORY 3- go run main.go  OR  go run projectName.go",
		"build":                      "1.build: The go build command compiles the source code in the current directory and generates an executable file.",
		"clean":                      "2.clean: The go clean command removes the output produced by the go build command,  including the executable and any temporary files that were created during the build.",
		"flag":                       "5.flag package: Command-line flags are a common way to specify options for command-line programs. For example, in wc -l the -l is a command-line flag. Go provides a flag package supporting basic command-line flag parsing. We'll use this package to implement our example command-line program.",
		"flag package":               "5.flag package: Command-line flags are a common way to specify options for command-line programs. For example, in wc -l the -l is a command-line flag. Go provides a flag package supporting basic command-line flag parsing. We'll use this package to implement our example command-line program.",
		"goroutine":                  "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"go routine":                 "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"goroutines":                 "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"channels":                   "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"goroutines and channels":    "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"channels and goroutines":    "138.Goroutines and Channels: What are they? Goroutines are lightweight threads created and managed by the Go runtime. Channels are pipes that carry values of a specific type. Why are they useful? Goroutines allow functions to be executed concurrently, without needing to deal with the complications of operating system threads. Channels allow goroutines to produce results asynchronously. How are they used? Goroutines are created using the go keyword. Channels are defined as data types. Are there any or limitations? pitfalls Care must be taken to manage the direction of channels. Goroutines that share data require additional features. Are there any alternatives? Goroutines and channels are the built-in Go concurrency features, but some applications can rely on a single thread of execution, which is created by default to execute the main function.",
		"regular expressions":        "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"regularexpressions":         "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"regex":                      "189.Regular Expressions: The regular expressions used in this section perform basic matches, but the regexp package supports an extensive pattern syntax, which is described at https://pkg.go.dev/regexp/syntax@go1.17.1.",
		"currying":                   "Currying: Function currying is the practice of writing a function that takes a function (or functions) as input, and returns a new function.",
		"trimspace(s)":               "TrimSpace(s): This function returns the string s without leading or trailing whitespace characters.",
		"trim(s, set)":               "Trim(s, set): This function returns a string from which any leading or trailing characters contained in the string set are removed from the string s.",
		"trimLeft(s, set)":           "This function returns the string s without any leading character contained in the string set. This function matches any of the specified characters‚Äîuse the TrimPrefix function to remove a complete substring.",
		"trimright(s, set)":          "This function returns the string s without any trailing character contained in the string set. This function matches any of the specified characters‚Äîuse the TrimSuffix function to remove a complete substring.",
		"trimprefix(s, prefix)":      "function returns the string s after removing the specified prefix string. This function removes the complete prefix string‚Äîuse the TrimLeft function to remove characters from a set.",
		"trimsuffix(s, suffix)":      "function returns the string s after removing the specified suffix string. This function removes the complete suffix string‚Äîuse the TrimRight function to remove characters from a set.",
		"trimfunc(s, func)":          "TrimFunc(s, func): This function returns the string s from which any leading or trailing character for which a custom function returns true are removed.",
		"trimleftFunc(s, func)":      "TrimLeftFunc(s, func): function returns the string s from which any leading character for which a custom function returns true are removed.",
		"trimrightFunc(s,    func)":  "TrimRightFunc(s, func): function returns the string s from which any trailing character for which a custom function returns true are removed.",
		"for":                        "56.for: Go allows loops only inside of functions. The for keyword is used to create loops that repeatedly execute statements. The most basic for loops will repeat indefinitely unless interrupted by the break keyword Incorporating the Condition into the Loop",
		"package":                    "Go applications are organized in packages. A package is a collection of source files located in the same directory. All source files in a directory must share the same package name. When a package is imported, only entities (functions, types, variables, constants) whose names start with a capital letter can be used / accessed. The recommended style of naming in Go is that identifiers will be named using camelCase, except for those meant to be accessible across packages which should be PascalCase. EXAMPLE: || package lasagna || ",
		"packages":                   "Go applications are organized in packages. A package is a collection of source files located in the same directory. All source files in a directory must share the same package name. When a package is imported, only entities (functions, types, variables, constants) whose names start with a capital letter can be used / accessed. The recommended style of naming in Go is that identifiers will be named using camelCase, except for those meant to be accessible across packages which should be PascalCase. EXAMPLE: || package lasagna || ",
		"variable":                   "Variables Go is statically-typed, which means all variables must have a defined type at compile-time.Variables can be defined by explicitly specifying a type, EXAMPLE: var explicit int || Explicitly typed||",
		"variables":                  "Variables Go is statically-typed, which means all variables must have a defined type at compile-time.Variables can be defined by explicitly specifying a type, EXAMPLE: var explicit int || Explicitly typed||",



		"constant":                   "Constants hold a piece of data just like variables, but their value cannot change during the execution of the program.Constants are defined using the const keyword and can be numbers, characters, strings or booleans. EXAMPLE:	const Age = 21",
		"constants":                  "Constants hold a piece of data just like variables, but their value cannot change during the execution of the program.Constants are defined using the const keyword and can be numbers, characters, strings or booleans. EXAMPLE:	const Age = 21",
		"function":                   "Go functions accept zero or more parameters. Parameters must be explicitly typed, there is no type inference. Values are returned from functions using the return keyword. A function is invoked by specifying the function name and passing arguments for each of the function's parameters.",
		"functions":                  "Go functions accept zero or more parameters. Parameters must be explicitly typed, there is no type inference. Values are returned from functions using the return keyword. A function is invoked by specifying the function name and passing arguments for each of the function's parameters.",
		"comment":                    "Note that Go supports two types of comments. Single line comments are preceded by // and multiline comments are inserted between /* and */.",
		"comments":                   "Note that Go supports two types of comments. Single line comments are preceded by // and multiline comments are inserted between /* and */.",
		"bool":                       "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"boolean":                    "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"booleans":                   "Booleans in Go are represented by the predeclared boolean type bool, which values can be either true or false. It's a defined type.",
		"package comments":           "Package comments should be written directly before a package clause (package x) and begin with Package x ...",
		"package comment":            "Package comments should be written directly before a package clause (package x) and begin with Package x ...",
		"function comment":           "A function comment should be written directly before the function declaration. It should be a full sentence that starts with the function name. For example, an exported comment for the function Calculate should take the form Calculate .... It should also explain what arguments the function takes, what it does with them, and what its return values mean, ending in a period):",
		"function comments":          "A function comment should be written directly before the function declaration. It should be a full sentence that starts with the function name. For example, an exported comment for the function Calculate should take the form Calculate .... It should also explain what arguments the function takes, what it does with them, and what its return values mean, ending in a period):",
		"number":                     "Go contains basic numeric types that can represent sets of either integer or floating-point values.",
		"numbers":                    "Go contains basic numeric types that can represent sets of either integer or floating-point values.",
		"int":                        "e.g. 0, 255, 2147483647. A signed integer that is at least 32 bits in size (value range of: -2147483648 through 2147483647). But this will depend on the systems architecture. Most modern computers are 64 bit, therefore int will be 64 bits in size (value rate of: -9223372036854775808 through 9223372036854775807).",
		"float64":                    "e.g. 0.0, 3.14. Contains the set of all 64-bit floating-point numbers.",
		"uint":                       "e.g. 0, 255. An unsigned integer that is the same size as int (value range of: 0 through 4294967295 for 32 bits and 0 through 18446744073709551615 for 64 bits)",
		"arithmetic operators":       "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"operator":                   "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"operators":                  "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"basic operator":             "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"basic operators":            "Go supports many standard arithmetic operators EXAMPLE: + , - , / , % ",
		"converting between types":   "Converting between types is done via a function with the name of the type to convert to. ",
	
		"arithmetic operations on different types": "In many languages you can perform arithmetic operations on different types of variables, but in Go this gives an error. ",
		"string": "A string in Go is an immutable sequence of bytes, which don't necessarily have to represent characters.",
		// using reflection
		"reflection":                    "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"reflections":                   "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"using reflection":              "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection?":           "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection ?":          "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection in Go?":     "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"what is reflection in Go ?":    "the Go support for reflection, which allows an application to work with types that are not known when the project is compiled, which is useful for creating APIs that will be used by other projects, for example. Reflection allows types and values to be inspected at runtime, even if those types were not defined at compile time. use this word for get example: reflection example",
		"why is reflection useful?":     "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is reflection useful ?":    "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is a reflection useful?":   "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"why is a reflection useful ?":  "Reflection is useful when writing code that relies on types that will be defined in the future, such as when writing an API that will be used in other projects. use this word for get example: reflection example",
		"how is reflection used?":       "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.  use this word for get example: reflection example",
		"how is reflection used ?":      "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.  use this word for get example: reflection example",
		"why the need for reflection?":  "The Go type system is rigorously enforced, which means you can't use a value of one type when a different type is inspected. sometime this is broken for wrong implementing. in this case, the empty interface, which can be used to accept any type.  use this word for get example: reflection example",
		"why the need for reflection ?": "The Go type system is rigorously enforced, which means you can't use a value of one type when a different type is inspected. sometime this is broken for wrong implementing. in this case, the empty interface, which can be used to accept any type.  use this word for get example: reflection example",
		"reflect package":               "The reflect package provides the Go reflection features, and the key functions are called TypeOf and ValueOf",
		// Generics
		"generic":                "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics":               "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics":   "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics?":  "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"what is the generics ?": "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"go generics":            "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics go":            "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		"generics in go":         "Generics help you to do more with less code, by using generic types instead of concrete types. While Generics have been part of other programming languages for quite some time, Generics was only recently added to Golang as of the 1.18 release in 2022. Generics can be used to define functions, structs and maps.",
		// Frameworks
		"beego":           "beego is used for rapid development of RESTful APIs, web apps and backend services in Go. It is inspired by Tornado, Sinatra and Flask. beego has some Go-specific features such as interfaces and struct embedding. Package beego provide a MVC framework beego: an open-source, high-performance, modular, full-stack web framework It is used for rapid development of RESTful APIs, web apps and backend services in Go. beego is inspired by Tornado, Sinatra and Flask with the added benefit of some Go-specific features such as interfaces and struct embedding.",
		"beego framework": "beego is used for rapid development of RESTful APIs, web apps and backend services in Go. It is inspired by Tornado, Sinatra and Flask. beego has some Go-specific features such as interfaces and struct embedding. Package beego provide a MVC framework beego: an open-source, high-performance, modular, full-stack web framework It is used for rapid development of RESTful APIs, web apps and backend services in Go. beego is inspired by Tornado, Sinatra and Flask with the added benefit of some Go-specific features such as interfaces and struct embedding.",
		// Database
		"database":                                         "There are drivers for a wide range of databases, and a list can be found at  https://github.com/golang/go/wiki/sqldrivers",
		"data base":                                        "There are drivers for a wide range of databases, and a list can be found at  https://github.com/golang/go/wiki/sqldrivers",
		"what is the database?":                            "The database/sql package provides features for working with SQL databases.",
		"what is the sql package?":                         "The database/sql package provides features for working with SQL databases.",
		"what is the database-sql package?":                "The database/sql package provides features for working with SQL databases.",
		"what is the database/sql package?":                "The database/sql package provides features for working with SQL databases.",
		"how is the database used?":                        "Relational databases remain the most effective way of storing large amounts of structured data and are used in most large projects.",
		"how is the database/sql used?":                    "Relational databases remain the most effective way of storing large amounts of structured data and are used in most large projects.",
		"Are in database any pitfalls or limitations?":     "These features do not automatically populate struct fields from result rows.",
		"Are in database/sql any pitfalls or limitations?": "These features do not automatically populate struct fields from result rows.",
		"Are in sql any pitfalls or limitations?":          "These features do not automatically populate struct fields from result rows.",
		"installing a database driver":                     "Run the command:==> go get modernc.org/sqlite  Most database servers are set up separately so that the database driver opens a connection to a separate process. SQLite is an embedded database and is included in the driver package, which means no additional configuration is required.",
		// Apache kafka
		"kafka":        "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"apacheKafka":  "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"apache Kafka": "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is exactly kafka apache for golang?":  "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is exactly kafka apache for golang ?": "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is kafka apache for golang?":          "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		"what is kafka apache for golang ?":         "Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. It is designed to handle high-throughput, fault-tolerant, and scalable messaging. Kafka allows you to publish and subscribe to streams of records, store them in a fault-tolerant way, and process them as they occur.",
		// Packages
		"strings":         "The strings package contains many useful functions to work on strings. For more information about string functions, check out the strings package documentation. Link: https://pkg.go.dev/strings",
		"package tar":     "Package tar implements access to tar archives.",
		"package zip":     "Package zip provides support for reading and writing ZIP archives.",
		"package arena":   "The arena package provides the ability to allocate memory for a collection of Go values and free that space manually all at once, safely.",
		"package bufio":   "bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O. ",
		"package builtin": "Package builtin provides documentation for Go's predeclared identifiers.",
		"package bytes":   "bytes implements functions for the manipulation of byte slices.",
		"package cmp":     "Package cmp provides types and functions related to comparing ordered values. Ordered is a constraint that permits any ordered type: any type // that supports the operators < <= >= >.// If future releases of Go add new ordered types,// this constraint will be modified to include them.",
		"package bzip2":   "Package bzip2 implements bzip2 decompression.",
		"package flate":   "Package flate implements the DEFLATE compressed data format, described in RFC 1951.",
		"package gzip":    "Package gzip implements reading and writing of gzip format compressed files, as specified in RFC 1952.",
		"package lzw":     "Package lzw implements the Lempel-Ziv-Welch compressed data format, described in T. A. Welch, ‚ÄúA Technique for High-Performance Data Compression‚Äù, Computer, 17(6) (June 1984), pp 8-19. ",
		"package zlib":    "Package zlib implements reading and writing of zlib format compressed data, as specified in RFC 1950. ",
		"package reflect": "The reflect package provides features that allow types and values to be reflected, such that they can be used without explicit knowledge of the data types in use.",
		// server
		"server": "server is a service for connection between clients and hosts. for get example of Go please write this: server example",
		// 487.Identifying Byte Slices
		"identifying byte slices": "Using the comparison operator is also a good way of using the Bytes method safety. The Bytes method will panic if it is called on any type other than a slice of bytes, but the Kind method only indicates slices and not their contents.",
		//
		// 488.go tool dist list
		"go tool dist list": `488üöÄ This will provide you a list of operating systems and architectures separated by / characters:`,
		"tool dist list":    `488üöÄ This will provide you a list of operating systems and architectures separated by / characters:`,
		"dist list":         `488üöÄ This will provide you a list of operating systems and architectures separated by / characters:`,
		// ioutil
		"ioutil": "The ioutil package in Go stands for 'input/output utility.' It is a package in the Go standard library that provides utility functions for I/O operations, particularly simplifying common tasks involving file I/O and reading from or writing to streams of data.",
		// Others
		"fuzzing":            "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"fuzzing definition": "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"fuzzing define":     "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing":    "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing?":   "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		"what is fuzzing ?":  "Fuzzing is the automatic process of giving random input to an application to look for any errors or any unexpected behavior. But finding any hidden directories and files on any web server can also be categorized under fuzzing. If we try to perform this process manually then it can take dozens of months to find the directories on the server. So the automation approach is the best for performing fuzzing. FFUF is the automated tool developed in the Golang language which is the fastest fuzzer tool in today‚Äôs date. It has various key features of manipulation the method from GET to POST and vice versa. We can use various wordlists for fuzzing the vhost as well. FFUF tool is an open-source and free-to-use tool. LINK:  https://www.geeksforgeeks.org/ffuf-fast-web-fuzzer-linux-tool-written-in-go/?ref=header_search",
		// Split
		"split()":                      "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"split() func":                 "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"split() function":             "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is the split() function": "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split() function":     "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split() ?":            "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split()?":             "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		"what is split()":              "Split() This function splits a slice of bytes into all subslices separated by the given separator and returns a slice which contains all these subslices. It is defined under the bytes package so, you have to import bytes package in your program for accessing Split function. Syntax: func Split(o_slice, sep []byte) [][]byte",
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		//
		// ==================================== FUNCTIONS ==============================================
		//47.Atoi(str) 49.FormatInt(val, base) 50.FormatUint(val, base)
		"atoi()":                 "47üöÄ Atoi(str) üîî This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"atoi(str)":              "47üöÄ Atoi(str) üîî This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"atoi(string)":           "47üöÄ Atoi(str) üîî This function parses a string into a base 10 int and is equivalent to calling ParseInt(str, 10, 0)",
		"formatint()":            "49üöÄ FormatInt(value, base) üîî This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatint(value, base)": "49üöÄ FormatInt(value, base) üîî This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatint(val, base)":   "49üöÄ FormatInt(value, base) üîî This function returns a string representation of the specified int64 value, expressed in the specified base.",
		"formatuint()":           "50üöÄ FormatUint(val, base) üîî This function returns a string representation of the specified uint64 value, expressed in the specified base.",
		"formatuint(val, base)":  "50üöÄ FormatUint(val, base) üîî This function returns a string representation of the specified uint64 value, expressed in the specified base.",
		//51.FormatFloat(val, format, precision, size)
		"formatfloat()":                             "51üöÄ FormatFloat(val, format, precision, size) üîî This function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		"formatfloat(1,2,3,4)":                      "51üöÄ FormatFloat(val, format, precision, size) üîîThis function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		"formatfloat(val, format, precision, size)": "51üöÄ FormatFloat(val, format, precision, size) üîîThis function returns a string representation of the specified float64 value, expressed using the specified format, precision, and size.",
		//52.Itoa(val)
		"itoa()":      "52üöÄ Itoa(val) üîî This function returns a string representation of the specified int value, expressed using base 10.",
		"itoa(val)":   "52üöÄ Itoa(val) üîî This function returns a string representation of the specified int value, expressed using base 10.",
		"itoa(value)": "52üöÄ Itoa(val) üîî This function returns a string representation of the specified int value, expressed using base 10.",
		// 165.Working with Character Case
		"islower(rune)":  "165üöÄ IsLower(rune) üîî This function returns true if the specified rune is lowercase.",
		"islower()":      "165üöÄ IsLower(rune) üîî This function returns true if the specified rune is lowercase.",
		"islower(r)":     "165üöÄ IsLower(rune) üîî This function returns true if the specified rune is lowercase.",
		"islower(runes)": "165üöÄ IsLower(rune) üîî This function returns true if the specified rune is lowercase.",
		"tolower(rune)":  "165üöÄ ToLower(rune) üîî This function returns the lowercase rune associated with the specified rune.",
		"tolower()":      "165üöÄ ToLower(rune) üîî This function returns the lowercase rune associated with the specified rune.",
		"tolower(r)":     "165üöÄ ToLower(rune) üîî This function returns the lowercase rune associated with the specified rune.",
		"tolower(runes)": "165üöÄ ToLower(rune) üîî This function returns the lowercase rune associated with the specified rune.",
		"isupper(rune)":  "165üöÄ IsUpper(rune) üîî This function returns true if the specified rune is uppercase.",
		"isupper(r)":     "165üöÄ IsUpper(rune) üîî This function returns true if the specified rune is uppercase.",
		"isupper(runes)": "165üöÄ IsUpper(rune) üîî This function returns true if the specified rune is uppercase.",
		"isupper()":      "165üöÄ IsUpper(rune) üîî This function returns true if the specified rune is uppercase.",
		"toupper(rune)":  "165üöÄ ToUpper(rune) üîî This function returns the upper rune associated with the specified rune.",
		"toupper()":      "165üöÄ ToUpper(rune) üîî This function returns the upper rune associated with the specified rune.",
		"toupper(r)":     "165üöÄ ToUpper(rune) üîî This function returns the upper rune associated with the specified rune.",
		"toupper(runes)": "165üöÄ ToUpper(rune) üîî This function returns the upper rune associated with the specified rune.",
		"istitle(rune)":  "165üöÄ IsTitle(rune) üîî This function returns true if the specified rune is title case.",
		"istitle()":      "165üöÄ IsTitle(rune) üîî This function returns true if the specified rune is title case.",
		"istitle(r)":     "165üöÄ IsTitle(rune) üîî This function returns true if the specified rune is title case.",
		"istitle(runes)": "165üöÄ IsTitle(rune) üîî This function returns true if the specified rune is title case.",
		"totitle(rune)":  "165üöÄ ToTitle(rune) üîî This function returns the title case rune associated with the specified rune.",
		"totitle()":      "165üöÄ ToTitle(rune) üîî This function returns the title case rune associated with the specified rune.",
		"totitle(r)":     "165üöÄ ToTitle(rune) üîî This function returns the title case rune associated with the specified rune.",
		"totitle(runes)": "165üöÄ ToTitle(rune) üîî This function returns the title case rune associated with the specified rune.",
		// 167.Inspecting Strings || The strings Functions for Inspecting Strings
		"count(s, sub)":                    "167üöÄ Count(s, sub) üîî This function returns an int that reports how many times the specified substring is found in the string s.",
		"count()":                          "167üöÄ Count(s, sub) üîî This function returns an int that reports how many times the specified substring is found in the string s.",
		"count(string, sub)":               "167üöÄ Count(s, sub) üîî This function returns an int that reports how many times the specified substring is found in the string s.",
		"index(s, sub)":                    "167üöÄ Index(s, sub) üîî These functions return the index of the first or last occurrence of a specified",
		"index()":                          "167üöÄ Index(s, sub) üîî These functions return the index of the first or last occurrence of a specified",
		"index(string, sub)":               "167üöÄ Index(s, sub) üîî These functions return the index of the first or last occurrence of a specified",
		"indexany(s, chars)":               "167üöÄ IndexAny(s, chars) üîî These functions return the first or last occurrence of any character in the...",
		"indexany()":                       "167üöÄ IndexAny(s, chars) üîî These functions return the first or last occurrence of any character in the...",
		"indexany(string, characters)":     "167üöÄ IndexAny(s, chars) üîî These functions return the first or last occurrence of any character in the...",
		"lastindexAny(s, chars)":           "167üöÄ LastIndexAny(s, chars) üîî specified string within the string s, or -1 if there is no occurrence.",
		"lastindexAny()":                   "167üöÄ LastIndexAny(s, chars) üîî specified string within the string s, or -1 if there is no occurrence.",
		"lastindexAny(string, characters)": "167üöÄ LastIndexAny(s, chars) üîî specified string within the string s, or -1 if there is no occurrence.",
		"indexbyte(s, b)":                  "167üöÄ IndexByte(s, b) üîî These functions return the index of the first or last occurrence of a specified",
		"indexbyte()":                      "167üöÄ IndexByte(s, b) üîî These functions return the index of the first or last occurrence of a specified",
		"indexbyte(string, byte)":          "167üöÄ IndexByte(s, b) üîî These functions return the index of the first or last occurrence of a specified",
		"lastindexByte(s, b)":              "167üöÄ LastIndexByte(s, b) üîî byte within the string s, or -1 if there is no occurrence.",
		"lastindexByte()":                  "167üöÄ LastIndexByte(s, b) üîî byte within the string s, or -1 if there is no occurrence.",
		"lastindexByte(string, byte)":      "167üöÄ LastIndexByte(s, b) üîî byte within the string s, or -1 if there is no occurrence.",
		"indexfunc(s, func)":               "167üöÄ IndexFunc(s, func) üîî These functions return the index of the first or last occurrence of the...",
		"indexfunc()":                      "167üöÄ IndexFunc(s, func) üîî These functions return the index of the first or last occurrence of the...",
		"indexfunc(string, function)":      "167üöÄ IndexFunc(s, func) üîî These functions return the index of the first or last occurrence of the...",
		"lastindexFunc(s, func)":           "167üöÄ LastIndexFunc(s, func) üîî  character in the string s for which the specified function returns true, as described in the ‚ÄúInspecting Strings with Custom Functions‚Äù section.",
		"lastindexFunc()":                  "167üöÄ LastIndexFunc(s, func) üîî  character in the string s for which the specified function returns true, as described in the ‚ÄúInspecting Strings with Custom Functions‚Äù section.",
		"lastindexFunc(string, function)":  "167üöÄ LastIndexFunc(s, func) üîî  character in the string s for which the specified function returns true, as described in the ‚ÄúInspecting Strings with Custom Functions‚Äù section.",
		//161.Comparing Strings
		"contains(s, substr)":            "161üöÄ Contains(s, substr) üîî This function returns true if the string s contains substr and false if it does not.",
		"contains()":                     "161üöÄ Contains(s, substr) üîî This function returns true if the string s contains substr and false if it does not.",
		"contains(string, substring)":    "161üöÄ Contains(s, substr) üîî This function returns true if the string s contains substr and false if it does not.",
		"containsany(s, substr)":         "161üöÄ ContainsAny(s, substr) üîî This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsany()":                  "161üöÄ ContainsAny(s, substr) üîî This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsany(string, substring)": "161üöÄ ContainsAny(s, substr) üîî This function returns true if the string s contains any of the characters contained in the string substr.",
		"containsrune(s, rune)":          "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune()":                 "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune(string, rune)":     "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune(string, r)":        "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune(string, R)":        "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune(s, R)":             "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"containsrune(S, R)":             "161üöÄ ContainsRune(s, rune) üîî This function returns true if the string s contains a specific rune.",
		"equalfold(s1, s2)":              "161üöÄ EqualFold(s1, s2) üîî This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold()":                    "161üöÄ EqualFold(s1, s2) üîî This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold(string, string)":      "161üöÄ EqualFold(s1, s2) üîî This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"equalfold(string1, string2)":    "161üöÄ EqualFold(s1, s2) üîî This function performs a case-insensitive comparison and returns true of strings s1 and s2 are the same.",
		"hasprefix(s, prefix)":           "161üöÄ HasPrefix(s, prefix) üîî This function returns true if the string s begins with the string prefix.",
		"hasprefix(s, p)":                "161üöÄ HasPrefix(s, prefix) üîî This function returns true if the string s begins with the string prefix.",
		"hasprefix(string, p)":           "161üöÄ HasPrefix(s, prefix) üîî This function returns true if the string s begins with the string prefix.",
		"hasprefix(string, prefix)":      "161üöÄ HasPrefix(s, prefix) üîî This function returns true if the string s begins with the string prefix.",
		"hasprefix()":                    "161üöÄ HasPrefix(s, prefix) üîî This function returns true if the string s begins with the string prefix.",
		"hassuffix(s, suffix)":           "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		"hassuffix(s, suf)":              "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		"hassuffix(string, suf)":         "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		"hassuffix(string, sufix)":       "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		"hassuffix()":                    "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		"hassuffix(string, string)":      "161üöÄ HasSuffix(s, suffix) üîî This function returns true if the string ends with the string suffix.",
		// 169.Splitting Strings
		"fields(s)":                     "169üöÄ Fields(s) üîî This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fields()":                      "169üöÄ Fields(s) üîî This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fields(string)":                "169üöÄ Fields(s) üîî This function splits a string on whitespace characters and returns a slice containing the nonwhitespace sections of the string s.",
		"fieldsfunc(s, func)":           "169üöÄ FieldsFunc(s, func) üîî This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"fieldsfunc()":                  "169üöÄ FieldsFunc(s, func) üîî This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"fieldsfunc(string, function)":  "169üöÄ FieldsFunc(s, func) üîî This function splits the string s on the characters for which a custom function returns true and returns a slice containing the remaining sections of the string.",
		"split(s, sub)":                 "169üöÄ Split(s, sub) üîî This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"split()":                       "169üöÄ Split(s, sub) üîî This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"split(string, sub)":            "169üöÄ Split(s, sub) üîî This function splits the string s on every occurrence of the specified substring, returning a string slice. If the separator is the empty string, then the slice will contain strings for each character.",
		"splitn(s, sub, max)":           "169üöÄ SplitN(s, sub, max) üîî This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitn()":                      "169üöÄ SplitN(s, sub, max) üîî This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitn(string, sub, max)":      "169üöÄ SplitN(s, sub, max) üîî This function is similar to Split, but accepts an additional int argument that specifies the maximum number of substrings to return. The last substring in the result slice will contain the unsplit portion of the source string.",
		"splitafter(s, sub)":            "169üöÄ SplitAfter(s, sub) üîî This function is similar to Split but includes the substring used in the results.",
		"splitafter()":                  "169üöÄ SplitAfter(s, sub) üîî This function is similar to Split but includes the substring used in the results.",
		"splitafter(string, sub)":       "169üöÄ SplitAfter(s, sub) üîî This function is similar to Split but includes the substring used in the results.",
		"splitaftern(s, sub, max)":      "169üöÄ SplitAfterN(s, sub, max) üîî This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		"splitaftern()":                 "169üöÄ SplitAfterN(s, sub, max) üîî This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		"splitaftern(string, sub, max)": "169üöÄ SplitAfterN(s, sub, max) üîî This function is similar to SplitAfter, but accepts an additional int argument that specifies the maximum number of substrings to return.",
		// 179.Altering Strings
		"replace(s, old, new, n)":           "179üöÄ Replace(s, old, new, n) üîî This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace()":                         "179üöÄ Replace(s, old, new, n) üîî This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n. Replace(s): This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(1, 2, 3, 4)":               "179üöÄ Replace(s, old, new, n) üîî This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace(1,2,3,4)":                  "179üöÄ Replace(s, old, new, n) üîî This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replace(string, old, new, number)": "179üöÄ Replace(s, old, new, n) üîî This function alters the string s by replacing occurrences of the string old with the string new. The maximum number of occurrences that will be replaced is specified by the int argument n.",
		"replaceall(s, old, new)":           "179üöÄ ReplaceAll(s, old, new) üîî This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"replaceall()":                      "179üöÄ ReplaceAll(s, old, new) üîî This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"replaceall(string, old, new)":      "179üöÄ ReplaceAll(s, old, new) üîî This function alters the string s by replacing all occurrences of the string old with the string new. Unlike the Replace function, there is no limit on the number of occurrences that will be replaced.",
		"map(func, s)":                      "179üöÄ Map(func, s) üîî This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		"map()":                             "179üöÄ Map(func, s) üîî This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		"map(function, string)":             "179üöÄ Map(func, s) üîî This function generates a string by invoking the custom function for each character in the string s and concatenating the results. If the function produces a negative value, the current character is dropped without a replacement.",
		//183.The Replacer Methods
		"replace(s)":             "183üöÄ Replace(s) üîî This method returns a string for which all the replacements specified with the constructor have been performed on the string s. Replace(s): This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(string)":        "183üöÄ Replace(s) üîî This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"replace(str)":           "183üöÄ Replace(s) üîî This method returns a string for which all the replacements specified with the constructor have been performed on the string s.",
		"writestring(writer, s)": "183üöÄ WriteString(writer, s) üîî This method is used to perform the replacements specified with the constructor and write the results to an io.Writer. This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, s)":      "183üöÄ WriteString(writer, s) üîî This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, str)":    "183üöÄ WriteString(writer, s) üîî This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		"writestring(w, string)": "183üöÄ WriteString(writer, s) üîî This method is used to perform the replacements specified with the constructor and write the results to an io.Writer",
		//184.Building and Generating Strings
		"join(slice, sep)":       "184üöÄ Join(slice, sep) üîî This function combines the elements in the specified string slice, with the specified separator string placed between elements. Join(slice, sep): function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"join(slice, specified)": "184üöÄ Join(slice, sep) üîî This function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"join()":                 "184üöÄ Join(slice, sep) üîî This function combines the elements in the specified string slice, with the specified separator string placed between elements.",
		"repeat(s, count)":       "184üöÄ Repeat(s, count) üîî This function generates a string by repeating the string s for a specified number of times.",
		"repeat(str, count)":     "184üöÄ Repeat(s, count) üîî This function generates a string by repeating the string s for a specified number of times.",
		//186.Building Strings
		"writestring(s)":      "186üöÄ WriteString(s) üîî This method appends the string s to the string being built.",
		"writestring(string)": "186üöÄ WriteString(s) üîî This method appends the string s to the string being built.",
		"writestring()":       "186üöÄ WriteString(s) üîî This method appends the string s to the string being built.",
		"writerune(r)":        "186üöÄ WriteRune(r) üîî This method appends the character r to the string being built.",
		"writerune()":         "186üöÄ WriteRune(r) üîî This method appends the character r to the string being built.",
		"writebyte(b)":        "186üöÄ WriteByte(b) üîî This method appends the byte b to the string being built.",
		"writebyte(byte)":     "186üöÄ WriteByte(b) üîî This method appends the byte b to the string being built.",
		"writebyte()":         "186üöÄ WriteByte(b) üîî This method appends the byte b to the string being built.",
		"string()":            "186üöÄ String() üîî This method returns the string that has been created by the builder.",
		"reset()":             "186üöÄ Reset() üîî This method resets the string created by the builder.",
		"len()":               "186üöÄ Len() üîî This method returns the number of bytes used to store the string created by the builder.",
		"cap()":               "186üöÄ Cap() üîî This method returns the number of bytes that have been allocated by the builder.",
		"grow(size)":          "186üöÄ Grow(size) üîî This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		"grow(siz)":           "186üöÄ Grow(size) üîî This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		"grow(sizes)":         "186üöÄ Grow(size) üîî This method increases the number of bytes used allocated by the builder to store the string that is being built.",
		//192.Useful Basic Regexp Methods
		"matchstring(s)":                   "192üöÄ MatchString(s) üîî This method returns true if the string s matches the compiled pattern.",
		"matchstring(str)":                 "192üöÄ MatchString(s) üîî This method returns true if the string s matches the compiled pattern.",
		"matchstring(string)":              "192üöÄ MatchString(s) üîî This method returns true if the string s matches the compiled pattern.",
		"matchstring(strings)":             "192üöÄ MatchString(s) üîî This method returns true if the string s matches the compiled pattern.",
		"findstringindex(s)":               "192üöÄ FindStringIndex(s) üîî This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(str)":             "192üöÄ FindStringIndex(s) üîî This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(string)":          "192üöÄ FindStringIndex(s) üîî This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstringindex(strings)":         "192üöÄ FindStringIndex(s) üîî This method returns an int slice containing the location for the left most match made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(s, max)":       "192üöÄ FindAllStringIndex(s, max) üîî This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(str, max)":     "192üöÄ FindAllStringIndex(s, max) üîî This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(string, max)":  "192üöÄ FindAllStringIndex(s, max) üîî This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findallstringindex(strings, max)": "192üöÄ FindAllStringIndex(s, max) üîî This method returns a slice of int slices that contain the location for all the matches made by the compiled pattern in the string s. A nil result indicates that no matches were made.",
		"findstring(s)":                    "192üöÄ FindString(s) üîî This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(str)":                  "192üöÄ FindString(s) üîî This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(string)":               "192üöÄ FindString(s) üîî This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findstring(strings)":              "192üöÄ FindString(s) üîî This method returns a string containing the left-most match made by the compiled pattern in the string s. An empty string will be returned if no match is made.",
		"findallstring(s, max)":            "192üöÄ FindAllString(s, max) üîî This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"findallstring(str, max)":          "192üöÄ FindAllString(s, max) üîî This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"findallstring(string, max)":       "192üöÄ FindAllString(s, max) üîî This method returns a string slice containing the matches made by the compiled pattern in the string s. The int argument max specifies the maximum number of matches, with -1 specifying no limit. A nil result is returned if there are no matches.",
		"split(s, max)":                    "192üöÄ Split(s, max) üîî This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		"split(str, max)":                  "192üöÄ Split(s, max) üîî This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		"split(string, max)":               "192üöÄ Split(s, max) üîî This method splits the string s using matches from the compiled pattern as separators and returns a slice containing the split substrings.",
		// 197.The Regexp Methods for Subexpressions
		"findstringsubmatch(s)":              "197üöÄ FindStringSubmatch(s) üîî This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findstringsubmatch(str)":            "197üöÄ FindStringSubmatch(s) üîî This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findstringsubmatch(string)":         "197üöÄ FindStringSubmatch(s) üîî This method returns a slice containing the first match made by the pattern and the text for the subexpressions that the pattern defines.",
		"findallstringsubmatch(s, max)":      "197üöÄ FindAllStringSubmatch(s, max) üîî This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findallstringsubmatch(str, max)":    "197üöÄ FindAllStringSubmatch(s, max) üîî This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findallstringsubmatch(string, max)": "197üöÄ FindAllStringSubmatch(s, max) üîî This method returns a slice containing all the matches and the text for the subexpressions. The int argument is used to specify the maximum number of matches. A value of -1 specifies all matches.",
		"findstringsubmatchindex(s)":         "197üöÄ FindStringSubmatchIndex(s) üîî This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"findstringsubmatchindex(str)":       "197üöÄ FindStringSubmatchIndex(s) üîî This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"findstringsubmatchindex(string)":    "197üöÄ FindStringSubmatchIndex(s) üîî This method is equivalent to FindStringSubmatch but returns indices rather than substrings. FindAllStringSubmatchIndex",
		"numsubexp()":                        "197üöÄ NumSubexp() üîî This method returns the number of subexpressions.",
		"subexpindex(name)":                  "197üöÄ SubexpIndex(name) üîî This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpindex(names)":                 "197üöÄ SubexpIndex(name) üîî This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpindex(n)":                     "197üöÄ SubexpIndex(name) üîî This method returns the index of the subexpression with the specified name or -1 if there is no such subexpression.",
		"subexpnames()":                      "197üöÄ SubexpNames() üîî This method returns the names of the subexpressions, expressed in the order in which they are defined.",
		//199.Replacing Substrings Using a Regular Expression
		"replaceallstring(s, template)":              "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(str, temp)":                "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(string, temp)":             "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(strings, temp)":            "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(strings, template)":        "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallstring(string, template)":         "199üöÄ ReplaceAllString(s, template) üîî This method replaces the matched portion of the string s with the specified template, which is expanded before it is included in the result to incorporate subexpressions.",
		"replaceallliteralstring(s, sub)":            "199üöÄ ReplaceAllLiteralString(s, sub) üîî This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(str, sub)":          "199üöÄ ReplaceAllLiteralString(s, sub) üîî This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(string, sub)":       "199üöÄ ReplaceAllLiteralString(s, sub) üîî This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallliteralstring(string, specified)": "199üöÄ ReplaceAllLiteralString(s, sub) üîî This method replaces the matched portion of the string s with the specified content, which is included in the result without being expanded for subexpressions.",
		"replaceallstringfunc(s, func)":              "199üöÄ ReplaceAllStringFunc(s, func) üîî This method replaces the matched portion of the string s with the result produced by the specified function.",
		"replaceallstringfunc(str, func)":            "199üöÄ ReplaceAllStringFunc(s, func) üîî This method replaces the matched portion of the string s with the result produced by the specified function.",
		"replaceallstringfunc(string, function)":     "199üöÄ ReplaceAllStringFunc(s, func) üîî This method replaces the matched portion of the string s with the result produced by the specified function.",
		// 203.fmt package
		"print(...vals)":            "203üöÄ Print(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print()":                   "203üöÄ Print(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print(...)":                "203üöÄ Print(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"print(...values)":          "203üöÄ Print(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out. Spaces are added between values that are not strings.",
		"println(...vals)":          "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(vals)":             "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println()":                 "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(values)":           "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(...value)":         "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"println(...)":              "203üöÄ Println(...vals) üîî This function accepts a variable number of arguments and writes out their values to the standard out, separated by spaces and followed by a newline character.",
		"fprint(writer, ...vals)":   "203üöÄ Fprint(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(w, ...vals)":        "203üöÄ Fprint(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(w, vals)":           "203üöÄ Fprint(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint()":                  "203üöÄ Fprint(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprint(wr, vals)":          "203üöÄ Fprint(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer, Spaces are added between values that are not strings.",
		"fprintln(writer, ...vals)": "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(wri, ...vals)":    "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, ...vals)":      "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, vals)":         "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, values)":       "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(w, v)":            "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln()":                "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		"fprintln(wrt, vls)":        "203üöÄ Fprintln(writer, ...vals) üîî This function writes out a variable number of arguments to the specified writer followed by a newline character. Spaces are added between all values.",
		//206.The fmt Functions for Formatting Strings
		"sprintf(t, ...vals)":         "206üöÄ Sprintf(t, ...vals) üîî This function returns a string, which is created by processing the template t.",
		"sprintf(t, vals)":            "206üöÄ Sprintf(t, ...vals) üîî This function returns a string, which is created by processing the template t.",
		"sprintf()":                   "206üöÄ Sprintf(t, ...vals) üîî This function returns a string, which is created by processing the template t.",
		"sprintf(1,...2)":             "206üöÄ Sprintf(t, ...vals) üîî This function returns a string, which is created by processing the template t.",
		"printf(t, ...vals)":          "206üöÄ Printf(t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(t, ...)":              "206üöÄ Printf(t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf()":                    "206üöÄ Printf(t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(1,2)":                 "206üöÄ Printf(t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"printf(1,...2)":              "206üöÄ Printf(t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to the standard out.",
		"fprintf(writer, t, ...vals)": "206üöÄ Fprintf(writer, t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf(write, t, ...vals)":  "206üöÄ Fprintf(writer, t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf()":                   "206üöÄ Fprintf(writer, t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"fprintf(1,2,3)":              "206üöÄ Fprintf(writer, t, ...vals) üîî This function creates a string by processing the template t. The remaining arguments are used as values for the template verbs. The string is written to a Writer, which is described in Chapter 20.",
		"errorf(t, ...values)":        "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(t, ...val)":           "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(t, ...vals)":          "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf()":                    "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(1,2)":                 "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		"errorf(1,...2)":              "206üöÄ Errorf(t, ...values) üîî This function creates an error by processing the template t. The remaining arguments are used as values for the template verbs. The result is an error value whose Error method returns the formatted string.",
		// 220.The fmt Functions for Scanning Strings
		"scan(...vals)":                       "220üöÄ Scan(...vals) üîî This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan(...)":                           "220üöÄ Scan(...vals) üîî This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan()":                              "220üöÄ Scan(...vals) üîî This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scan(...2)":                          "220üöÄ Scan(...vals) üîî This function reads text from the standard in and stores the space- separated values into specified arguments. Newlines are treated as spaces, and the function reads until it has received values for all of its arguments. The result is the number of values that have been read and an error that describes any problems.",
		"scanln(...vals)":                     "220üöÄ Scanln(...vals) üîî This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln(...)":                         "220üöÄ Scanln(...vals) üîî This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln()":                            "220üöÄ Scanln(...vals) üîî This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanln(...2)":                        "220üöÄ Scanln(...vals) üîî This function works in the same way as Scan but stops reading when it encounters a newline character.",
		"scanf(template, ...vals)":            "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(temp, ...vals)":                "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(temp, ...values)":              "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(1,2)":                          "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf(1,...2)":                       "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"scanf()":                             "220üöÄ Scanf(template, ...vals) üîî This function works in the same way as Scan but uses a template string to select the values from the input it receives.",
		"fscan(reader, ...vals)":              "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reade, ...vals)":               "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reader, ...values)":            "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(reader, values)":               "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan(1,2)":                          "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscan()":                             "220üöÄ Fscan(reader, ...vals) üîî This function reads space-separated values from the specified reader, which is described in Chapter 20. Newlines are treated as spaces, and the function returns the number of values that have been read and an error that describes any problems.",
		"fscanln(reader, ...vals)":            "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(reader, ...values)":          "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(reader, values)":             "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(read, values)":               "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln(1,2)":                        "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanln()":                           "220üöÄ Fscanln(reader, ...vals) üîî This function works in the same way as Fscan but stops reading when it encounters a newline character.",
		"fscanf(reader, template, ...vals)":   "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, template, ...values)": "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, template, values)":    "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(reader, temp, values)":        "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, values)":          "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, val)":             "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(read, temp, vals)":            "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(1,2,3)":                       "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf(1, 2, 3)":                     "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"fscanf()":                            "220üöÄ Fscanf(reader, template, ...vals) üîî This function works in the same way as Fscan but uses a template to select the values from the input it receives.",
		"sscan(str, ...vals)":                 "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(str, vals)":                    "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(str, values)":                  "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(string, values)":               "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(string, ...values)":            "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan()":                             "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(1,2)":                          "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscan(1, 2)":                         "220üöÄ Sscan(str, ...vals) üîî This function scans the specified string for space-separated values, which are assigned to the remaining arguments. The result is the number of values scanned and an error that describes any problems.",
		"sscanf(str, template, ...vals)":      "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, ...vals)":   "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, vals)":      "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(string, template, values)":    "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, template, values)":       "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, temp, values)":           "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(str, temp, vals)":             "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(1,2,3)":                       "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf(1, 2, 3)":                     "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanf()":                            "220üöÄ Sscanf(str, template, ...vals) üîî This function works in the same way as Sscan but uses a template to select values from the string. Sscanln(str, template, ...vals)     This function works in the same way as Sscanf but stops scanning the",
		"sscanln(str, template, ...vals)":     "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, ...vals)":  "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, vals)":     "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(string, template, values)":   "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, temp, vals)":            "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, template, vals)":        "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(str, template, values)":      "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(1,2,3)":                      "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln(1, 2, 3)":                    "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		"sscanln()":                           "220üöÄ Sscanln(str, template, ...vals) üîî This function works in the same way as Sscanf but stops scanning the string as soon as a newline character is encountered.",
		//226.Useful Functions from the math Package
		"abs(val)":         "226üöÄ Abs(val) üîî This function returns the absolute value of a float64 value, meaning the distance from zero without considering direction.",
		"abs()":            "226üöÄ Abs(val) üîî This function returns the absolute value of a float64 value, meaning the distance from zero without considering direction.",
		"ceil(val)":        "226üöÄ Ceil(val) üîî This function returns the smallest integer that is equal to or greater than the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"ceil()":           "226üöÄ Ceil(val) üîî This function returns the smallest integer that is equal to or greater than the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"copysign(x, y)":   "226üöÄ Copysign(x, y) üîî This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign(1,2)":    "226üöÄ Copysign(x, y) üîî This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign(1, 2)":   "226üöÄ Copysign(x, y) üîî This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"copysign()":       "226üöÄ Copysign(x, y) üîî This function returns a float64 value, which is the absolute value of x with the sign of y.",
		"floor(val)":       "226üöÄ Floor(val) üîî This function returns the largest integer that is smaller or equal to the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"floor()":          "226üöÄ Floor(val) üîî This function returns the largest integer that is smaller or equal to the specified float64 value. The result is also a float64 value, even though it represents an integer number.",
		"max(x, y)":        "226üöÄ Max(x, y) üîî This function returns whichever of the specified float64 value is the largest.",
		"max(x,y)":         "226üöÄ Max(x, y) üîî This function returns whichever of the specified float64 value is the largest.",
		"max(1,2)":         "226üöÄ Max(x, y) üîî This function returns whichever of the specified float64 value is the largest.",
		"max(1, 2)":        "226üöÄ Max(x, y) üîî This function returns whichever of the specified float64 value is the largest.",
		"max()":            "226üöÄ Max(x, y) üîî This function returns whichever of the specified float64 value is the largest.",
		"min(x, y)":        "226üöÄ Min(x, y) üîî This function returns whichever of the specified float64 value is smallest.",
		"min(x,y)":         "226üöÄ Min(x, y) üîî This function returns whichever of the specified float64 value is smallest.",
		"min(1,2)":         "226üöÄ Min(x, y) üîî This function returns whichever of the specified float64 value is smallest.",
		"min(1, 2)":        "226üöÄ Min(x, y) üîî This function returns whichever of the specified float64 value is smallest.",
		"min()":            "226üöÄ Min(x, y) üîî This function returns whichever of the specified float64 value is smallest.",
		"mod(x, y)":        "226üöÄ Mod(x, y) üîî This function returns the remainder of x/y.",
		"mod(x,y)":         "226üöÄ Mod(x, y) üîî This function returns the remainder of x/y.",
		"mod(1,2)":         "226üöÄ Mod(x, y) üîî This function returns the remainder of x/y.",
		"mod(1, 2)":        "226üöÄ Mod(x, y) üîî This function returns the remainder of x/y.",
		"mod()":            "226üöÄ Mod(x, y) üîî This function returns the remainder of x/y.",
		"pow(x, y)":        "226üöÄ Pow(x, y) üîî This function returns x raised to the exponent y.",
		"pow(x,y)":         "226üöÄ Pow(x, y) üîî This function returns x raised to the exponent y.",
		"pow()":            "226üöÄ Pow(x, y) üîî This function returns x raised to the exponent y.",
		"pow(1,2)":         "226üöÄ Pow(x, y) üîî This function returns x raised to the exponent y.",
		"pow(1, 2)":        "226üöÄ Pow(x, y) üîî This function returns x raised to the exponent y.",
		"round(val)":       "226üöÄ Round(val) üîî This function rounds the specified value to the nearest integer, rounding half values up. The result is a float64 value, even though it represents an integer.",
		"round()":          "226üöÄ Round(val) üîî This function rounds the specified value to the nearest integer, rounding half values up. The result is a float64 value, even though it represents an integer.",
		"roundtoeven(val)": "226üöÄ RoundToEven(val) üîî This function rounds the specified value to the nearest integer, rounding half values to the nearest even number. The result is a float64 value, even though it represents an integer.",
		"roundtoeven()":    "226üöÄ RoundToEven(val) üîî This function rounds the specified value to the nearest integer, rounding half values to the nearest even number. The result is a float64 value, even though it represents an integer.",
		//228.Generating Random Numbers
		"seed(s)":              "228 üöÄ Seed(s) üîî This function sets the seed value using the specified int64 value.",
		"seed()":               "228 üöÄ Seed(s) üîî This function sets the seed value using the specified int64 value.",
		"float32()":            "228 üöÄ Float32() üîî This function generates a random float32 value between 0 and 1.",
		"float64()":            "228 üöÄ Float64() üîî This function generates a random float64 value between 0 and 1.",
		"int()":                "228 üöÄ Int() üîî This function generates a random int value.",
		"intn(max)":            "228 üöÄ Intn(max) üîî This function generates a random int smaller than a specified value, as described after the table.",
		"intn()":               "228 üöÄ Intn(max) üîî This function generates a random int smaller than a specified value, as described after the table.",
		"uint32()":             "228 üöÄ UInt32() üîî This function generates a random uint32 value.",
		"uint64()":             "228 üöÄ UInt64() üîî This function generates a random uint64 value.",
		"shuffle(count, func)": "228 üöÄ Shuffle(count, func) üîî This function is used to randomize the order of elements, as described after the table.",
		//234.The Basic Functions for Sorting
		"float64s(slice)":          "234üöÄ Float64s(slice) üîî This function sorts a slice of float64 values. The elements are sorted in place.",
		"float64s()":               "234üöÄ Float64s(slice) üîî This function sorts a slice of float64 values. The elements are sorted in place.",
		"float64saresorted(slice)": "234üöÄ Float64sAreSorted(slice) üîî This function returns true if the elements in the specified float64 slice are in order.",
		"float64saresorted()":      "234üöÄ Float64sAreSorted(slice) üîî This function returns true if the elements in the specified float64 slice are in order.",
		"ints(slice)":              "234üöÄ Ints(slice) üîî This function sorts a slice of int values. The elements are sorted in place.",
		"ints()":                   "234üöÄ Ints(slice) üîî This function sorts a slice of int values. The elements are sorted in place.",
		"intsaresorted(slice)":     "234üöÄ IntsAreSorted(slice) üîî This function returns true if the elements in the specified int slice are in order.",
		"intsaresorted()":          "234üöÄ IntsAreSorted(slice) üîî This function returns true if the elements in the specified int slice are in order.",
		"strings(slice)":           "234üöÄ Strings(slice) üîî This function sorts a slice of string values. The elements are sorted in place.",
		"strings()":                "234üöÄ Strings(slice) üîî This function sorts a slice of string values. The elements are sorted in place.",
		"stringsaresorted(slice)":  "234üöÄ StringsAreSorted(slice) üîî This function returns true if the elements in the specified string slice are in order.",
		"stringsaresorted()":       "234üöÄ StringsAreSorted(slice) üîî This function returns true if the elements in the specified string slice are in order.",
		//478.The Key Reflection Functions
		"typeof(val)":  "478üöÄ TypeOf(val) üîî This function returns a value that implements the Type interface, which describes the type of the specified value. There is a lot of detail behind the TypeOf and ValueOf functions and their results, and it is easy to lose sight of why reflection can be useful.",
		"valueof(val)": "478üöÄ ValueOf(val) üîî This function returns a Value struct, which allows the specified value to be inspected and manipulated. There is a lot of detail behind the TypeOf and ValueOf functions and their results, and it is easy to lose sight of why reflection can be useful.",
		//481.Basic Methods Defined by the Type Interface
		"name()":             "481üöÄ Name() 	üîî This method returns the name of the type.",
		"pkgpath()":          "481üöÄ PkgPath() 	üîî This method returns the package path for the type. The empty string is returned for built-in types, such as int and bool.",
		"kind()":             "481üöÄ Kind() 	üîî This method returns the kind of type, using a value that matches one of the constant values defined by the reflect package, as described in Table 27-5.",
		"481 string()":       "481üöÄ String() 	üîî This method returns a string representation of the type name, including the package name.",
		"comparable()":       "481üöÄ Comparable() üîî This method returns true if values of this type can be compared using the standard comparison operator, as described in the ‚ÄúComparing Values‚Äù section.",
		"assignableto(type)": "481üöÄ AssignableTo(type) üîî This method returns true if values of this type can be assigned to variables or fields of the specified reflected type.",
		"assignableto()":     "481üöÄ AssignableTo(type) üîî This method returns true if values of this type can be assigned to variables or fields of the specified reflected type.",
		//484.Using the Basic Value Features
		"484 kind()":   "484üöÄ Kind()      üîî This method returns the kind of the value's type.",
		"type()":       "484üöÄ Type()      üîî This method returns the Type for the Value.",
		"isnil()":      "484üöÄ IsNil()     üîî This method returns true if the value is nil. This method will panic if the underlying value isn't a function, an interface, a pointer, a slice, or a channel.",
		"iszero()":     "484üöÄ IsZero()    üîî This method returns true if the underlying value is the zero value for its type.",
		"bool()":       "484üöÄ Bool()      üîî This method returns the underlying bool value. The method panics if the underlying value's Kind is not Bool.",
		"bytes()":      "484üöÄ Bytes()     üîî This method returns the underlying []byte value. The method panics if the underlying value is not a byte slice. I demonstrate how to determine the type of a slice in the ‚ÄúIdentifying Byte Slices‚Äù section.",
		"484 int()":    "484üöÄ Int()       üîî This method returns the underlying value as an int64. The method panics if the underlying value's Kind is not Int, Int8, Int16, Int32, or Int64.",
		"unit()":       "484üöÄ Uint()      üîî This method returns the underlying value as an uint64. The method panics if the underlying value's Kind is not Uint, Uint8, Uint16, Uint32, or Uint64.",
		"float()":      "484üöÄ Float()     üîî This method returns the underlying value as an float64. The method panics if the underlying value's Kind is not Float32, or Float64.",
		"484 string()": "484üöÄ String()    üîî This method returns the underlying value as a string if the value's Kind is String. For other Kind values, this method returns the string <T Value> where T is the underlying type, such as <int Value>.",
		"elem()":       "484üöÄ Elem()      üîî This method returns the Value to which a pointer refers. This method can also be used with interfaces, as described in Chapter 29. This method panics if the underlying value's Kind is not Ptr.",
		"isvalid()":    "484üöÄ IsValid()   üîî This method returns false if the Value is the zero value, created as Value{} rather than obtained using ValueOf, for example. This method doesn't relate to reflected values that are the zero value of their reflected type. If this method returns false, then all other Value methods will panic.",
		//
		// üöÄüöÄüöÄüöÄüöÄüöÄ üîîüîîüîîüîîüîîüîî

	},
}

func GetMapReturnSlice() []string {
	// Step 2: Initialize a slice to hold the keys
	var Keys []string

	// Step 3: Iterate over the map and append Keys to the slice
	for key := range OriginSingleDef.SingleDef {
		Keys = append(Keys, key)
	}

	return Keys
}

// ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
